# Undo/Redo and Restorable Historical States

Since every change a user makes is immediately saved, it's important to provide a robust way for users to undo anything they've done during a session (possibly up to some limit) in a very granular way.

In addition, we want to allow the user to recover previous versions of a project or stack, both those explicitly saved as named versions and, within reason, some set of automatically generated previous states.

These are probably different, but we may end up providing related solutions.

Assuming that all state changes are performed via actions, we can use a redux-like approach for high-granularity undo/redo as described here: http://rackt.org/redux/docs/recipes/ImplementingUndoHistory.html. The only requirement for this to work is that we maintain any separable application state as a single object modified only through dispatched actions (separable meaning that it's reasonable to save and undo independently from other application state - probably the project is the boundary for this).

Let's say that problem is solved.

Now we want to worry about restoring previous states at a much coarser level, certainly a project, possibly a stack.

One way to do this is to store all the data as flat files and then use git for versioning. The entire history will be available, and we have support for transactions and, using tags, for named previous versions.

There are potential problems with distributed systems, but the really easy way around that is to let a project be its own repository and to have each project associated with a single master server. That means that access to files in the project can be completely controlled and we don't have merge issues since we'll serialize all incoming changes. I can't really think of any reason NOT to do it this way.

So Git works fine, but my instinct is that it's too heavy a solution for what we really need. Git is designed to be distributed, but the object we really need to version isn't, in fact, distributed. With serialized access, I think there is a much simpler solution. All it takes is a per-project timestamp (really just a counter). 

Let's augment our storage structure as follows. Every directory has a subdirectory called _history_ and a version file called _version.[timestamp-value]_. Let's say the last timestamp file in the directory was _version.1555_ and the current timestamp is 2312. If we change (or add) a file _foo_ in that directory we:

* Copy the current file _foo_ (if it exists) to ./history/_foo.1555_
* Create the file _version.2312_
* Overwrite _foo_ with the new version.
* Delete the file _version.1555_

Now the state of the project is completely described by a single number corresponding to the latest timestamp corresponding to that state and it's relatively easy to write a function to pull out any file or the entire tree corresponding to that value. Saved states (or tags) simply involve associating a name with a timestamp. That can be part of the project metadata - we'll store some set of standard tags that are autogenerated plus any tags the user has. 

The history directories will become somewhat cluttered, but it's trivial to write a function to purge them periodically.

By default, of course, if there is no version file, then we always just return the files in the directory. Anyone writing by hand can just work normally without worrying about versioning.

The one thing we don't get here is transactions. However, I think that's pretty straightforward just using a multi-segment counter and a procedure to mark the beginning and end of the transaction that allows us to tell if it failed in the middle (e.g., if we reboot in the middle). It's also possible to maintain additional counters for stack and card levels, if we want.

Incidentally, because of the way we expect to implement changes to the system (via dispatched actions), it's trivial to do a "journaling" filesystem in which we write the command(s) we're about to do, then write when we've done it (them). This would allow us to even complete a transaction if we crashed in the middle.


